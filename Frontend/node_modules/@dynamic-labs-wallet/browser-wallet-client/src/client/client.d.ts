import { type MessageTransportWithDefaultOrigin } from '@dynamic-labs/message-transport';
import { iframeMessageHandler } from '../services/iframeMessageHandler';
import type { GetWalletResponse, CreateWalletAccountResponse, RequiresPasswordForOperationRequest, SignMessageRequest, IsPasswordEncryptedRequest, BackupKeySharesToGoogleDriveRequest, VerifyPasswordRequest, UpdatePasswordRequest, ImportPrivateKeyRequest, ExportClientKeysharesRequest, OfflineExportPrivateKeyResponse, SignRawMessageRequest, CreateWalletAccountRequest, SignTransactionRequest, RefreshWalletAccountSharesRequest, ReshareRequest } from '@dynamic-labs-wallet/core';
import { WalletOperation } from '@dynamic-labs-wallet/core';
export declare class DynamicWalletClient {
    protected chainName: string;
    protected logger: import("@dynamic-labs/logger").Logger;
    instanceId: string | null;
    iframeDomain: string | null;
    environmentId: string;
    private readonly authToken;
    baseApiUrl: string;
    baseMPCRelayApiUrl: string;
    protected messageTransport: MessageTransportWithDefaultOrigin | null;
    protected iframeMessageHandler: iframeMessageHandler | null;
    private static iframeLoadPromise;
    protected iframe: HTMLIFrameElement | null;
    private debug;
    private static sharedIframe;
    private static iframeInstanceCount;
    constructor({ environmentId, authToken, baseApiUrl, baseMPCRelayApiUrl, chainName, debug, }: {
        environmentId: string;
        authToken: string;
        baseApiUrl: string;
        baseMPCRelayApiUrl: string;
        chainName: string;
        debug?: boolean;
    });
    initialize(): Promise<void>;
    /**
     * this is called on class construction time
     * @returns {Promise<void>} that resolves when the iframe is loaded and the message transport and iframe storage are initialized
     */
    initializeIframeCommunication(): Promise<void>;
    /**
     * initialize the iframe communication by awaiting the iframe load promise
     * and initializing the message transport and iframe storage after iframe is successfully loaded
     */
    private doInitializeIframeCommunication;
    /**
     * initialize the message transport after iframe is successfully loaded
     */
    private initializeMessageTransport;
    /**
     * securely exchange the auth token with iframe securely
     */
    private initAuthToken;
    private loadIframe;
    /**
     * Load an iframe for a specific container
     * @param {HTMLElement} container - The container to which the iframe will be attached
     * @returns {Promise<HTMLIFrameElement>} that resolves when the iframe is loaded
     */
    private loadIframeForContainer;
    /**
     * Initializes the iframe display for a specific container.
     *
     * @param {HTMLElement} container - The container to which the iframe will be attached.
     * @returns:
     *   iframe: HTMLIFrameElement;
     *   iframeDisplay: IframeDisplayChannelAdapter;
     *   cleanup: () => void;
     */
    initializeIframeDisplayForContainer({ container, }: {
        container: HTMLElement;
    }): Promise<{
        iframe: HTMLIFrameElement;
        iframeDisplay: iframeMessageHandler;
        cleanup: () => void;
    }>;
    getWallets(): Promise<GetWalletResponse[]>;
    getWallet({ accountAddress, walletOperation, signedSessionId, }: {
        accountAddress: string;
        walletOperation?: WalletOperation;
        signedSessionId?: string;
    }): Promise<GetWalletResponse>;
    createWalletAccount({ thresholdSignatureScheme, password, signedSessionId, }: Omit<CreateWalletAccountRequest, 'chainName'>): Promise<CreateWalletAccountResponse>;
    requiresPasswordForOperation({ accountAddress, walletOperation, }: Omit<RequiresPasswordForOperationRequest, 'chainName'>): Promise<boolean>;
    isPasswordEncrypted({ accountAddress, }: Omit<IsPasswordEncryptedRequest, 'chainName'>): Promise<boolean>;
    signMessage({ message, accountAddress, password, signedSessionId, }: Omit<SignMessageRequest, 'chainName'>): Promise<string>;
    signRawMessage({ message, accountAddress, password, signedSessionId, }: Omit<SignRawMessageRequest, 'chainName'>): Promise<string>;
    /**
     * Signs a transaction and returns the signature, @transaction is a string of the serialized transaction
     * EVM:
     *   transaction = serializeTransaction()
     * SOL:
     *   const messageBytes = transaction.serializeMessage();
     *   const messageToSign = Buffer.from(messageBytes).toString("hex");
     * SUI:
     *  const txBytes = await txb.build({ client });
     *  const txString = Buffer.from(txBytes).toString("hex");
     */
    signTransaction({ senderAddress, transaction, password, signedSessionId, }: Omit<SignTransactionRequest, 'chainName'>): Promise<string>;
    backupKeySharesToGoogleDrive({ accountAddress, password, signedSessionId, }: Omit<BackupKeySharesToGoogleDriveRequest, 'chainName'>): Promise<void>;
    restoreBackupFromGoogleDrive({ accountAddress, displayContainer, password, signedSessionId, }: {
        accountAddress: string;
        displayContainer: HTMLElement;
        password?: string;
        signedSessionId?: string;
    }): Promise<void>;
    refreshWalletAccountShares({ accountAddress, password, signedSessionId, }: Omit<RefreshWalletAccountSharesRequest, 'chainName'>): Promise<void>;
    reshare({ accountAddress, oldThresholdSignatureScheme, newThresholdSignatureScheme, password, signedSessionId, }: Omit<ReshareRequest, 'chainName'>): Promise<void>;
    exportPrivateKey({ accountAddress, displayContainer, password, signedSessionId, }: {
        accountAddress: string;
        displayContainer: HTMLElement;
        password?: string;
        signedSessionId?: string;
    }): Promise<void>;
    verifyPassword({ accountAddress, password, walletOperation, signedSessionId, }: Omit<VerifyPasswordRequest, 'chainName'>): Promise<void>;
    updatePassword({ accountAddress, existingPassword, newPassword, signedSessionId, }: Omit<UpdatePasswordRequest, 'chainName'>): Promise<void>;
    importPrivateKey({ privateKey, thresholdSignatureScheme, }: Omit<ImportPrivateKeyRequest, 'chainName'>): Promise<CreateWalletAccountResponse>;
    exportClientKeyshares({ accountAddress, password, signedSessionId, }: Omit<ExportClientKeysharesRequest, 'chainName'>): Promise<void>;
    /**
     * keyShares is stringified list of EcdsaKeygenResult[] and Ed25519KeygenResult[]
     */
    offlineExportPrivateKey({ keyShares, derivationPath, }: {
        keyShares: string[];
        derivationPath?: string;
    }): Promise<OfflineExportPrivateKeyResponse>;
    cleanup(): Promise<void>;
}
//# sourceMappingURL=client.d.ts.map