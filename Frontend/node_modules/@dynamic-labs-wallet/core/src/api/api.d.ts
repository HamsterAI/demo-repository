import type { ThresholdSignatureScheme } from '../mpc/constants';
import { BaseClient } from './client';
import { type KeygenCompleteResponse, type OpenRoomResponse, type ReshareResponse } from '../types';
export declare class DynamicApiClient extends BaseClient {
    constructor({ environmentId, authToken, baseApiUrl, }: {
        environmentId: string;
        authToken: string;
        baseApiUrl?: string;
    });
    authenticateApiToken({ environmentId }: {
        environmentId: string;
    }): Promise<import("axios").AxiosResponse<any, any>>;
    createWalletAccount({ chainName, clientKeygenIds, thresholdSignatureScheme, onError, onCeremonyComplete, }: {
        chainName: string;
        clientKeygenIds: string[];
        thresholdSignatureScheme: ThresholdSignatureScheme;
        onError?: (error: Error) => void;
        onCeremonyComplete?: (accountAddress: string, walletId: string) => void;
    }): Promise<KeygenCompleteResponse>;
    signMessage({ walletId, message, onError, isFormatted, }: {
        walletId: string;
        message: string;
        onError?: (error: Error) => void;
        isFormatted?: boolean;
    }): Promise<OpenRoomResponse>;
    refreshWalletAccountShares({ walletId, onError, }: {
        walletId: string;
        onError?: (error: Error) => void;
    }): Promise<{
        roomId: string;
        serverKeygenIds: string[];
    }>;
    reshare({ walletId, clientKeygenIds, oldThresholdSignatureScheme, newThresholdSignatureScheme, onError, }: {
        walletId: string;
        clientKeygenIds: string[];
        oldThresholdSignatureScheme: ThresholdSignatureScheme;
        newThresholdSignatureScheme: ThresholdSignatureScheme;
        onError?: (error: Error) => void;
    }): Promise<ReshareResponse>;
    exportKey({ walletId, exportId, onError, }: {
        walletId: string;
        exportId: string;
        onError?: (error: Error) => void;
    }): Promise<OpenRoomResponse>;
    storeEncryptedBackupByWallet({ walletId, encryptedKeyShares, passwordEncrypted, signedSessionId, }: {
        walletId: string;
        encryptedKeyShares: string[];
        passwordEncrypted: boolean;
        signedSessionId?: string;
    }): Promise<any>;
    markKeySharesAsBackedUpGoogleDrive({ walletId }: {
        walletId: string;
    }): Promise<any>;
    recoverEncryptedBackupByWallet({ walletId, keyShareIds, signedSessionId, }: {
        walletId: string;
        keyShareIds?: string[];
        signedSessionId?: string;
    }): Promise<any>;
    getAccessToken({ oauthAccountId }: {
        oauthAccountId: string;
    }): Promise<any>;
    importPrivateKey({ chainName, clientKeygenIds, thresholdSignatureScheme, onError, onCeremonyComplete, }: {
        chainName: string;
        clientKeygenIds: string[];
        thresholdSignatureScheme: ThresholdSignatureScheme;
        onError?: (error: Error) => void;
        onCeremonyComplete?: (accountAddress: string, walletId: string) => void;
    }): Promise<KeygenCompleteResponse>;
    getUser(): Promise<any>;
    refreshUser(): Promise<any>;
}
//# sourceMappingURL=api.d.ts.map